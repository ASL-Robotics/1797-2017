package org.usfirst.frc.team1797.util;

import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.interfaces.Gyro;
import jaci.pathfinder.Trajectory;
import jaci.pathfinder.Trajectory.Segment;
import jaci.pathfinder.modifiers.TankModifier;

/**
 * The TankDriveEncoderFollower is a utility class designed work with
 * Trajectories generated by the
 * {@link <a href="https://github.com/JacisNonsense/Pathfinder">Pathfinder</a>}
 * library.
 * <p>
 * The intention of this class is to guide a tank drive along a trajectory based
 * on encoder and gyro inputs.
 *
 * @author kaito_arai@asl.org
 * @version %I%, %G%
 */
public class TankDriveEncoderFollower {

	Trajectory leftTrajectory, rightTrajectory;

	Encoder leftEncoder, rightEncoder;
	Gyro gyro;

	RobotDrive robotDrive;

	double kp, kd, kv, kAc, kAn, dt, length;

	/**
	 * Constructs a TankDriveEncoderFollower object by passing parameters
	 * necessary for generating left and right trajectories, tracking robot
	 * position, and following the trajectories.
	 * <p>
	 * The recommended order of tuning is kv, kAc, kp, kd, then kAn.
	 * 
	 * @param source
	 *            The source trajectory to base the left and right trajectories
	 *            off of
	 * @param drivetrainWidth
	 *            The perpendicular distance between the two sets of wheels in
	 *            meters
	 * @param gyro
	 *            The gyro input which corresponds to the orientation of the
	 *            drivetrain
	 * @param leftEncoder
	 *            The encoder input which corresponds to the rotation of the
	 *            left wheels
	 * @param rightEncoder
	 *            The encoder input which corresponds to the rotation of the
	 *            right wheels
	 * @param robotDrive
	 *            The drivetrain
	 * @param kp
	 *            The proportional term for feedback control.
	 * @param kd
	 *            The derivative term for feedback control.
	 * @param kv
	 *            The velocity term for feedforward control. This should be
	 *            1/Vmax; therefore, this term should require no tuning as it is
	 *            a constant.
	 * @param kAc
	 *            The acceleration term for feedforward control.
	 * @param kAn
	 *            The angle term for feedback control. Tune this last.
	 */

	public TankDriveEncoderFollower(Trajectory source, double drivetrainWidth, Gyro gyro, Encoder leftEncoder,
			Encoder rightEncoder, RobotDrive robotDrive, double kp, double kd, double kv, double kAc, double kAn) {

		TankModifier tankModifier = new TankModifier(source).modify(drivetrainWidth);
		leftTrajectory = tankModifier.getLeftTrajectory();
		rightTrajectory = tankModifier.getRightTrajectory();

		this.leftEncoder = leftEncoder;
		this.rightEncoder = rightEncoder;
		this.gyro = gyro;

		this.robotDrive = robotDrive;

		dt = source.get(0).dt;
		length = source.length();

		this.kp = kp;
		this.kd = kd;
		this.kv = kv;
		this.kAc = kAc;
		this.kAn = kAn;
	}

	/**
	 * Follows given trajectory based on values passed in the constructor.
	 */
	public void execute() {
		double leftError, rightError, angleError, lastLeftError = 0, lastRightError = 0, leftValue, rightValue;
		Segment leftSegment, rightSegment;

		double initLeftEncoderDistance = leftEncoder.getDistance(),
				initRightEncoderDistance = rightEncoder.getDistance(), initGyroAngle = Math.toRadians(gyro.getAngle()),
				initTime = Timer.getFPGATimestamp();

		for (int i = 0; i < length; i++) {
			leftSegment = leftTrajectory.get(i);
			rightSegment = rightTrajectory.get(i);

			leftError = leftSegment.position - leftEncoder.getDistance() + initLeftEncoderDistance;
			rightError = rightSegment.position - rightEncoder.getDistance() + initRightEncoderDistance;
			angleError = leftSegment.heading - Math.toRadians(gyro.getAngle()) + initGyroAngle;

			leftValue = kv * leftSegment.velocity + kAc * leftSegment.acceleration + kp * leftError
					+ kd * (leftError - lastLeftError) / dt - kAn * angleError;
			rightValue = kv * rightSegment.velocity + kAc * rightSegment.acceleration + kp * rightError
					+ kd * (rightError - lastRightError) / dt + kAn * angleError;

			robotDrive.tankDrive(leftValue, rightValue);

			lastLeftError = leftError;
			lastRightError = rightError;

			Timer.delay(dt * (i + 1) - Timer.getFPGATimestamp() + initTime);
		}

		robotDrive.stopMotor();
	}
}